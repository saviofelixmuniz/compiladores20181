grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"

Model:
	(elements+=sourcefile)*;
  
sourcefile:
	{sourcefile} packageclause=packageclause ";" (importdecl+=importdecl ";")* (topleveldecl+=topleveldecl ";")*
;

empty:
	ANY_OTHER
;

importdecl:
	"import" (importspec | "(" (importspec ";")* ")")
;

importspec:
	("." | packagename)? importpath
;

importpath:
	string_lit
;

packageclause:
	"package" packagename
;
	
expression: 
	unaryexpr expressionaux+=expressionaux
;

expressionaux:
	BINARY_OP=BINARY_OP expression=expression expressionaux+=expressionaux |
	{expressionaux} empty=empty
;

unaryexpr:
	primaryexpr=primaryexpr | UNARY_OP=UNARY_OP unaryexpr=unaryexpr
;

primaryexpr:
	operand=operand primaryexpraux=primaryexpraux | 
	conversion=conversion primaryexpraux=primaryexpraux |
	methodexpr=methodexpr primaryexpraux=primaryexpraux 
;

primaryexpraux:
	selector=selector primaryexpraux=primaryexpraux | 
	index=index primaryexpraux=primaryexpraux | 
	slice=slice primaryexpraux=primaryexpraux | 
	typeassertion=typeassertion primaryexpraux=primaryexpraux | 
	arguments=arguments primaryexpraux=primaryexpraux |
	{primaryexpraux} empty=empty
;
 
index:
	"[" expression "]"
;

slice:
	{slice} "[" expression+=expression? ":" expression+=expression? "]" |
	"[" expression? ":" expression+=expression ":" expression+=expression "]"
;

methodexpr:
	receivertype "." methodname=methodname
;

receivertype:
	type
;

conversion:
	type=type "(" expression=expression ","? ")"
;

operand:
	{operand} literal=literal | {operand} operandname=operandname | "(" expression ")"
;

compositelit:
	literaltype=literaltype literalvalue=literalvalue
;

literaltype:
	{literaltype} structtype=structtype | arraytype=arraytype | {literaltype} "[" "..." "]" elementtype=elementtype |
	 {literaltype} slicetype=slicetype | {literaltype} maptype=maptype | {literaltype} typename=typename
;

arraytype:
	"[" arraylength "]" elementtype=elementtype
;

arraylength:
	expression
;

literalvalue:
	{literalvalue} "{" (elementlist=elementlist ","?)? "}"
;

elementlist:
	keyedelement ("," keyedelement+=keyedelement)*
;

keyedelement:
	(key ":")? element=element
;

key:
	{key} fieldname=fieldname | expression | literalvalue
;

element:
	expression | literalvalue
;
	
functionlit:
	"func" signature functionbody+=functionbody
;

statement:
	declaration | labeledstmt | simplestmt
	| gostmt | returnstmt | {statement} breakstmt=breakstmt 
	| {statement} continuestmt=continuestmt | {statement} gotostmt=gotostmt | {statement} fallthroughstmt=fallthroughstmt 
	| block | ifstmt | switchstmt 
	| selectstmt | deferstmt | {statement} forstmt=forstmt
;

forstmt:
	"for" (condition | forclause | rangeclause)? b=block
;

rangeclause:
	(expressionlist "=" | idlist=identifierlist ":=")? "range" expr=expression
;

condition:
	expression
;

poststmt:
	simplestmt
;

initstmt:
	simplestmt
;

forclause:
	{forclause} initstmt=initstmt? ";" condition=condition? ";" poststmt=poststmt?
;

deferstmt:
	"defer" expression
;

selectstmt:
	{selectstmt} "select" "{" commclause+=commclause* "}"
;

switchstmt:
	exprswitchstmt | typeswitchstmt
;

typeswitchstmt:
	"switch" (simplestmt ";")? typeswitchguard=typeswitchguard "{" typecaseclause+=typecaseclause* "}"
;

typeswitchguard:
	(IDENTIFIER=IDENTIFIER ":=")? primaryexpr=primaryexpr "." "(" "type" ")"
;

typecaseclause:
	typeswitchcase ":" statementlist=statementlist
;

typeswitchcase:
	"case" typelist | {typeswitchcase} "default"
;

typelist:
	type ("," type+=type)*
; 

commclause:
	commcase ":" stmtlist=statementlist
;

commcase:
	"case" (sendstmt | recvstmt) |  {commcase} "default"
;

recvexpr:
	expression
;

recvstmt:
	(expressionlist "=" | identifierlist=identifierlist ":=")? recvexpr=recvexpr
;

exprswitchcase:
	"case" expressionlist | {exprswitchcase} "default"
;

exprswitchstmt:
	{exprswitchstmt} "switch" (simplestmt=simplestmt ";")? expr=expression? "{" exprcaseclause+=exprcaseclause* "}" 
;

exprcaseclause:
	exprswitchcase ":" statementlist=statementlist
;

ifstmt:
	"if" (simplestmt ";")? exp+=expression block+=block ("else" (ifstmt=ifstmt | block+=block))?
;

breakstmt:
	"break" label?
;

continuestmt:
	"continue" label?
;

gotostmt:
	"goto" label
;

fallthroughstmt:
	"fallthrough"
;

returnstmt:
	{returnstmt} "return" expressionlist=expressionlist? 
;

gostmt:
	"go" expression
;

labeledstmt:
	label=label ":" statement=statement
;

label:
	IDENTIFIER
;

varspec:
	identifierlist=identifierlist (type=type ("=" expressionlist=expressionlist)? | "=" expressionlist=expressionlist)
;

declaration:
	constdecl | typedecl=typedecl | vardecl
;

typedecl:
	{typedecl} "type" (typespec+=typespec | "(" (typespec+=typespec ";")* ")")	
;

typespec:
	aliasdecl | typedef
;

typedef:
	IDENTIFIER=IDENTIFIER type=type
;

vardecl:
	{vardecl} "var" (varspec+=varspec | "(" (varspec+=varspec ";")* ")")
;

aliasdecl:
	IDENTIFIER=IDENTIFIER "=" type=type
;

constdecl:
	{constdecl} "const" (constspec+=constspec | "(" (constspec+=constspec ";")* ")")
;

constspec:
	{constspec} identifierlist=identifierlist (type=type? "=" expressionlist=expressionlist)?
;

topleveldecl:
	declaration | functiondecl | methoddecl
;

functiondecl:
	"func" functionname=functionname signature=signature functionbody+=functionbody?
;

functionname:
	IDENTIFIER
;

methoddecl:
	"func" receiver methodname=methodname signature=signature funcbody+=functionbody?
;

receiver:
	parameters
;

simplestmt:
	{simplestmt} emptystmt=emptystmt | expressionstmt | sendstmt | incdecstmt | assignment | shortvardecl
;

expressionstmt:
	expression
;

sendstmt:
	channel "<-" expression+=expression
;

incdecstmt:
	expression ("++" | "--")
;

assignment:
	expressionlist assign_op=assign_op expressionlist=expressionlist
;

shortvardecl:
	id=identifierlist ":=" expressionlist=expressionlist	
;

assign_op:
	(ADD_OP | MUL_OP)? "="
;

channel:
	expression+=expression
;

emptystmt:
	";"
;

block:
	"{" statementlist "}"
;

statementlist:
	{statementlist} (statement+=statement ";")*
;

functionbody:
	block
;	

typeassertion:
	"." "(" type ")"
;

arguments:
	{arguments} "(" ((expressionlist=expressionlist | type=type ("," expressionlist=expressionlist)?) "..."? ","?)? ")"
;

expressionlist:
	expression ("," expression+=expression)*
;

selector:
	"." IDENTIFIER
;

fieldname:
	IDENTIFIER
;

literal:
	basiclit=basiclit |
	compositelit=compositelit |
	functionlit=functionlit
;

basiclit:
	int_lit | float_lit | imaginary_lit | rune_lit | string_lit
;

operandname:
	IDENTIFIER | qualified_ident
;
	
slicetype: 
	"[" "]" elementtype
;

pointertype:
	"*" basetype
;

basetype:
	type
;

channeltype:
	( "chan" | "chan" "<-" | "<-" "chan" ) elementtype
;

maptype:
	"map" "[" keytype "]" elementtype=elementtype
;
	
keytype:
	type
;

elementtype:
	type
;

interfacetype:
	{interfacetype} "interface" "{" (methodspec+=methodspec ";")* "}"
;

methodspec:
	methodname=methodname signature=signature  | {methodspec} interfacetypename=interfacetypename
;

methodname:
	IDENTIFIER
;

interfacetypename:
	typename
;

functiontype:
	"func" signature
;

signature:
	parameters result=result?
;

result:
	parameters | type
;

parameters:
	{parameters} "(" (parameterlist=parameterlist ","?)? ")"
;

parameterlist:
	parameterdecl ("," parameterdecl+=parameterdecl)*
;

parameterdecl:
	identifierlist=identifierlist? "..."? type=type
;

structtype:
	{structtype} "struct" "{" (fielddecl+=fielddecl ";")* "}"
;

fielddecl:
	{fielddecl} (identifierlist=identifierlist type=type | embeddedfield=embeddedfield) tag=tag?
;

embeddedfield:
	"*"? typename
;

type:
	{type} typename=typename |
	typelit |
	"(" type ")"
;

typelit:
	arraytype=arraytype | structtype=structtype |pointertype=pointertype |
	functiontype=functiontype | interfacetype=interfacetype | slicetype=slicetype |
	maptype=maptype | channeltype=channeltype
;

identifierlist:
	IDENTIFIER ( "," IDENTIFIER)*
;

tag:
	string_lit
;

typename:
	IDENTIFIER | qualified_ident
;

qualified_ident:
	packagename "." IDENTIFIER
;

packagename:
	IDENTIFIER
;

string_lit:
	raw_string_lit | interpreted_string_lit
;

raw_string_lit:
	"`" (LETTER | DECIMAL_DIGIT | "\\n")* "`"
;

interpreted_string_lit:
	"\"" (unicode_value | byte_value)* "\""
;

rune_lit:
	"'" (unicode_value | byte_value) "'"
;

int_lit:
	(DECIMAL_DIGIT | hex_lit)*
;

hex_lit:
	"0" ("x" | "X") HEX_DIGIT+
;

imaginary_lit:
	(decimals | float_lit) "i"
;

float_lit:
	(decimals "." decimals? exponent?) | (decimals exponent) | "." decimals exponent?
;

exponent:
	("e" | "E") ("+" | "-")? decimals
;

decimals:
	DECIMAL_DIGIT+
;

byte_value:
	octal_byte_value | hex_byte_value	
;

hex_byte_value: 
	'\\' "x" HEX_DIGIT HEX_DIGIT
;

octal_byte_value:
	'\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT
;

unicode_value:
	(LETTER | DECIMAL_DIGIT) | little_u_value | big_u_value | ESCAPED_CHAR
;

big_u_value: 
	"\\" "U" HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
;

little_u_value: 
	"\\" "u" HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT 
;

KEYWORD
    : 'break'
    | 'default'
    | 'func'
    | 'interface'
    | 'select'
    | 'case'
    | 'defer'
    | 'go'
    | 'map'
    | 'struct'
    | 'chan'
    | 'else'
    | 'goto'
    | 'package'
    | 'switch'
    | 'const'
    | 'fallthrough'
    | 'if'
    | 'range'
    | 'type'
    | 'continue'
    | 'for'
    | 'import'
    | 'return'
    | 'var'
    ;

terminal IDENTIFIER: 
	LETTER (LETTER | DECIMAL_DIGIT)*
;

terminal A_F: 
	"A" .. "F" | "a" .. "f" 
;

terminal LETTER:
	A_F | 'g' .. 'z' | 'G' .. 'Z' | "_"
;

terminal HEX_DIGIT:
	DECIMAL_DIGIT | A_F
;

terminal OCTAL_DIGIT:
	('0'..'7')
;

terminal ESCAPED_CHAR:
	"\\" ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | "\\" | "\'" | "\"" )
;

terminal DECIMAL_DIGIT:
	OCTAL_DIGIT | '8' | '9';

terminal BINARY_OP:
	"||" | "&&" | REL_OP | ADD_OP | MUL_OP
;

terminal REL_OP:
	"==" | "!=" | "<" | "<=" | ">" | ">="
;

terminal ADD_OP:
	"+" | "-" | "|" | "^"
;

terminal MUL_OP:
	"*" | "/" | "%" | "<<" | ">>" | "&" | "&^"
;

terminal UNARY_OP:
	"+" | "-" | "!" | "^" | "*" | "&" | "<-"
;	