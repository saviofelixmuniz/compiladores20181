/*
 * generated by Xtext 2.14.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.aliasdecl;
import org.xtext.example.mydsl.myDsl.arguments;
import org.xtext.example.mydsl.myDsl.arraytype;
import org.xtext.example.mydsl.myDsl.assignmentaux;
import org.xtext.example.mydsl.myDsl.commcase;
import org.xtext.example.mydsl.myDsl.compositelit;
import org.xtext.example.mydsl.myDsl.constdecl;
import org.xtext.example.mydsl.myDsl.constspec;
import org.xtext.example.mydsl.myDsl.conversion;
import org.xtext.example.mydsl.myDsl.declaration;
import org.xtext.example.mydsl.myDsl.exprcaseclause;
import org.xtext.example.mydsl.myDsl.expressionaux;
import org.xtext.example.mydsl.myDsl.exprswitchcase;
import org.xtext.example.mydsl.myDsl.exprswitchstmt;
import org.xtext.example.mydsl.myDsl.fielddecl;
import org.xtext.example.mydsl.myDsl.forclause;
import org.xtext.example.mydsl.myDsl.forstmt;
import org.xtext.example.mydsl.myDsl.functiondecl;
import org.xtext.example.mydsl.myDsl.functionlit;
import org.xtext.example.mydsl.myDsl.ifstmt;
import org.xtext.example.mydsl.myDsl.interfacetype;
import org.xtext.example.mydsl.myDsl.key;
import org.xtext.example.mydsl.myDsl.keyedelement;
import org.xtext.example.mydsl.myDsl.labeledstmt;
import org.xtext.example.mydsl.myDsl.literal;
import org.xtext.example.mydsl.myDsl.literaltype;
import org.xtext.example.mydsl.myDsl.literalvalue;
import org.xtext.example.mydsl.myDsl.methoddecl;
import org.xtext.example.mydsl.myDsl.methodexpr;
import org.xtext.example.mydsl.myDsl.methodspec;
import org.xtext.example.mydsl.myDsl.operand;
import org.xtext.example.mydsl.myDsl.parameterdecl;
import org.xtext.example.mydsl.myDsl.parameterlist;
import org.xtext.example.mydsl.myDsl.parameters;
import org.xtext.example.mydsl.myDsl.postexpressionlist;
import org.xtext.example.mydsl.myDsl.primaryexpr;
import org.xtext.example.mydsl.myDsl.primaryexpraux;
import org.xtext.example.mydsl.myDsl.rangeclause;
import org.xtext.example.mydsl.myDsl.recvstmt;
import org.xtext.example.mydsl.myDsl.returnstmt;
import org.xtext.example.mydsl.myDsl.selectstmt;
import org.xtext.example.mydsl.myDsl.sendstmt;
import org.xtext.example.mydsl.myDsl.sendstmtaux;
import org.xtext.example.mydsl.myDsl.shortvardecl;
import org.xtext.example.mydsl.myDsl.signature;
import org.xtext.example.mydsl.myDsl.simplestmt;
import org.xtext.example.mydsl.myDsl.slice;
import org.xtext.example.mydsl.myDsl.sourcefile;
import org.xtext.example.mydsl.myDsl.statement;
import org.xtext.example.mydsl.myDsl.statementlist;
import org.xtext.example.mydsl.myDsl.structtype;
import org.xtext.example.mydsl.myDsl.switchstmt;
import org.xtext.example.mydsl.myDsl.topleveldecl;
import org.xtext.example.mydsl.myDsl.type;
import org.xtext.example.mydsl.myDsl.typeaux;
import org.xtext.example.mydsl.myDsl.typecaseclause;
import org.xtext.example.mydsl.myDsl.typedecl;
import org.xtext.example.mydsl.myDsl.typedef;
import org.xtext.example.mydsl.myDsl.typelist;
import org.xtext.example.mydsl.myDsl.typelit;
import org.xtext.example.mydsl.myDsl.typespec;
import org.xtext.example.mydsl.myDsl.typeswitchcase;
import org.xtext.example.mydsl.myDsl.typeswitchguard;
import org.xtext.example.mydsl.myDsl.typeswitchstmt;
import org.xtext.example.mydsl.myDsl.unaryexpr;
import org.xtext.example.mydsl.myDsl.vardecl;
import org.xtext.example.mydsl.myDsl.varspec;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ALIASDECL:
				sequence_aliasdecl(context, (aliasdecl) semanticObject); 
				return; 
			case MyDslPackage.ARGUMENTS:
				sequence_arguments(context, (arguments) semanticObject); 
				return; 
			case MyDslPackage.ARRAYTYPE:
				sequence_arraytype(context, (arraytype) semanticObject); 
				return; 
			case MyDslPackage.ASSIGNMENTAUX:
				sequence_assignmentaux(context, (assignmentaux) semanticObject); 
				return; 
			case MyDslPackage.COMMCASE:
				if (rule == grammarAccess.getCommcaseRule()) {
					sequence_commcase(context, (commcase) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCommclauseRule()) {
					sequence_commcase_commclause(context, (commcase) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.COMPOSITELIT:
				sequence_compositelit(context, (compositelit) semanticObject); 
				return; 
			case MyDslPackage.CONSTDECL:
				sequence_constdecl(context, (constdecl) semanticObject); 
				return; 
			case MyDslPackage.CONSTSPEC:
				sequence_constspec(context, (constspec) semanticObject); 
				return; 
			case MyDslPackage.CONVERSION:
				sequence_conversion(context, (conversion) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION:
				sequence_declaration(context, (declaration) semanticObject); 
				return; 
			case MyDslPackage.EXPRCASECLAUSE:
				sequence_exprcaseclause(context, (exprcaseclause) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSIONAUX:
				sequence_expressionaux(context, (expressionaux) semanticObject); 
				return; 
			case MyDslPackage.EXPRSWITCHCASE:
				sequence_exprswitchcase(context, (exprswitchcase) semanticObject); 
				return; 
			case MyDslPackage.EXPRSWITCHSTMT:
				sequence_exprswitchstmt(context, (exprswitchstmt) semanticObject); 
				return; 
			case MyDslPackage.FIELDDECL:
				sequence_fielddecl(context, (fielddecl) semanticObject); 
				return; 
			case MyDslPackage.FORCLAUSE:
				if (rule == grammarAccess.getForclauseRule()) {
					sequence_forclause(context, (forclause) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getForstmtRule()) {
					sequence_forclause_forstmt(context, (forclause) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.FORSTMT:
				sequence_forstmt(context, (forstmt) semanticObject); 
				return; 
			case MyDslPackage.FUNCTIONDECL:
				sequence_functiondecl(context, (functiondecl) semanticObject); 
				return; 
			case MyDslPackage.FUNCTIONLIT:
				sequence_functionlit(context, (functionlit) semanticObject); 
				return; 
			case MyDslPackage.IFSTMT:
				sequence_ifstmt(context, (ifstmt) semanticObject); 
				return; 
			case MyDslPackage.INTERFACETYPE:
				sequence_interfacetype(context, (interfacetype) semanticObject); 
				return; 
			case MyDslPackage.KEY:
				if (rule == grammarAccess.getElementlistRule()) {
					sequence_elementlist_key_keyedelement(context, (key) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyRule()) {
					sequence_key(context, (key) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedelementRule()) {
					sequence_key_keyedelement(context, (key) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.KEYEDELEMENT:
				if (rule == grammarAccess.getElementlistRule()) {
					sequence_elementlist_keyedelement(context, (keyedelement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedelementRule()) {
					sequence_keyedelement(context, (keyedelement) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.LABELEDSTMT:
				sequence_labeledstmt(context, (labeledstmt) semanticObject); 
				return; 
			case MyDslPackage.LITERAL:
				sequence_literal(context, (literal) semanticObject); 
				return; 
			case MyDslPackage.LITERALTYPE:
				sequence_literaltype(context, (literaltype) semanticObject); 
				return; 
			case MyDslPackage.LITERALVALUE:
				sequence_literalvalue(context, (literalvalue) semanticObject); 
				return; 
			case MyDslPackage.METHODDECL:
				sequence_methoddecl(context, (methoddecl) semanticObject); 
				return; 
			case MyDslPackage.METHODEXPR:
				sequence_methodexpr(context, (methodexpr) semanticObject); 
				return; 
			case MyDslPackage.METHODSPEC:
				sequence_methodspec(context, (methodspec) semanticObject); 
				return; 
			case MyDslPackage.OPERAND:
				sequence_operand(context, (operand) semanticObject); 
				return; 
			case MyDslPackage.PARAMETERDECL:
				sequence_parameterdecl(context, (parameterdecl) semanticObject); 
				return; 
			case MyDslPackage.PARAMETERLIST:
				sequence_parameterlist(context, (parameterlist) semanticObject); 
				return; 
			case MyDslPackage.PARAMETERS:
				sequence_parameters(context, (parameters) semanticObject); 
				return; 
			case MyDslPackage.POSTEXPRESSIONLIST:
				sequence_postexpressionlist(context, (postexpressionlist) semanticObject); 
				return; 
			case MyDslPackage.PRIMARYEXPR:
				sequence_primaryexpr(context, (primaryexpr) semanticObject); 
				return; 
			case MyDslPackage.PRIMARYEXPRAUX:
				sequence_primaryexpraux(context, (primaryexpraux) semanticObject); 
				return; 
			case MyDslPackage.RANGECLAUSE:
				sequence_rangeclause(context, (rangeclause) semanticObject); 
				return; 
			case MyDslPackage.RECVSTMT:
				sequence_recvstmt(context, (recvstmt) semanticObject); 
				return; 
			case MyDslPackage.RETURNSTMT:
				sequence_returnstmt(context, (returnstmt) semanticObject); 
				return; 
			case MyDslPackage.SELECTSTMT:
				sequence_selectstmt(context, (selectstmt) semanticObject); 
				return; 
			case MyDslPackage.SENDSTMT:
				sequence_sendstmt(context, (sendstmt) semanticObject); 
				return; 
			case MyDslPackage.SENDSTMTAUX:
				sequence_sendstmtaux(context, (sendstmtaux) semanticObject); 
				return; 
			case MyDslPackage.SHORTVARDECL:
				sequence_shortvardecl(context, (shortvardecl) semanticObject); 
				return; 
			case MyDslPackage.SIGNATURE:
				sequence_signature(context, (signature) semanticObject); 
				return; 
			case MyDslPackage.SIMPLESTMT:
				if (rule == grammarAccess.getSimplestmtRule()) {
					sequence_simplestmt(context, (simplestmt) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeswitchstmtRule()) {
					sequence_simplestmt_typeswitchstmt(context, (simplestmt) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.SLICE:
				sequence_slice(context, (slice) semanticObject); 
				return; 
			case MyDslPackage.SOURCEFILE:
				sequence_sourcefile(context, (sourcefile) semanticObject); 
				return; 
			case MyDslPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case MyDslPackage.STATEMENTLIST:
				sequence_statementlist(context, (statementlist) semanticObject); 
				return; 
			case MyDslPackage.STRUCTTYPE:
				sequence_structtype(context, (structtype) semanticObject); 
				return; 
			case MyDslPackage.SWITCHSTMT:
				sequence_switchstmt(context, (switchstmt) semanticObject); 
				return; 
			case MyDslPackage.TOPLEVELDECL:
				sequence_topleveldecl(context, (topleveldecl) semanticObject); 
				return; 
			case MyDslPackage.TYPE:
				if (rule == grammarAccess.getMaptypeRule()) {
					sequence_maptype_type(context, (type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getTypeassertionRule()
						|| rule == grammarAccess.getSlicetypeRule()
						|| rule == grammarAccess.getPointertypeRule()
						|| rule == grammarAccess.getBasetypeRule()
						|| rule == grammarAccess.getChanneltypeRule()
						|| rule == grammarAccess.getKeytypeRule()
						|| rule == grammarAccess.getElementtypeRule()
						|| rule == grammarAccess.getResultRule()) {
					sequence_type(context, (type) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.TYPEAUX:
				sequence_typeaux(context, (typeaux) semanticObject); 
				return; 
			case MyDslPackage.TYPECASECLAUSE:
				sequence_typecaseclause(context, (typecaseclause) semanticObject); 
				return; 
			case MyDslPackage.TYPEDECL:
				sequence_typedecl(context, (typedecl) semanticObject); 
				return; 
			case MyDslPackage.TYPEDEF:
				sequence_typedef(context, (typedef) semanticObject); 
				return; 
			case MyDslPackage.TYPELIST:
				sequence_typelist(context, (typelist) semanticObject); 
				return; 
			case MyDslPackage.TYPELIT:
				sequence_typelit(context, (typelit) semanticObject); 
				return; 
			case MyDslPackage.TYPESPEC:
				sequence_typespec(context, (typespec) semanticObject); 
				return; 
			case MyDslPackage.TYPESWITCHCASE:
				sequence_typeswitchcase(context, (typeswitchcase) semanticObject); 
				return; 
			case MyDslPackage.TYPESWITCHGUARD:
				sequence_typeswitchguard(context, (typeswitchguard) semanticObject); 
				return; 
			case MyDslPackage.TYPESWITCHSTMT:
				sequence_typeswitchstmt(context, (typeswitchstmt) semanticObject); 
				return; 
			case MyDslPackage.UNARYEXPR:
				if (rule == grammarAccess.getRecvstmtRule()) {
					sequence_expression_expressionlist_recvstmt_unaryexpr(context, (unaryexpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionlistRule()) {
					sequence_expression_expressionlist_unaryexpr(context, (unaryexpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getForstmtRule()) {
					sequence_expression_forstmt_unaryexpr(context, (unaryexpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getIndexRule()
						|| rule == grammarAccess.getElementRule()
						|| rule == grammarAccess.getDeferstmtRule()
						|| rule == grammarAccess.getRecvexprRule()
						|| rule == grammarAccess.getGotstmtRule()) {
					sequence_expression_unaryexpr(context, (unaryexpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnaryexprRule()) {
					sequence_unaryexpr(context, (unaryexpr) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.VARDECL:
				sequence_vardecl(context, (vardecl) semanticObject); 
				return; 
			case MyDslPackage.VARSPEC:
				sequence_varspec(context, (varspec) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     typespecaux returns aliasdecl
	 *     aliasdecl returns aliasdecl
	 *
	 * Constraint:
	 *     type=type
	 */
	protected void sequence_aliasdecl(ISerializationContext context, aliasdecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPESPECAUX__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPESPECAUX__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAliasdeclAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     arguments returns arguments
	 *
	 * Constraint:
	 *     (expressionlist=expressionlist | (type=type expressionlist=expressionlist?))?
	 */
	protected void sequence_arguments(ISerializationContext context, arguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     arraytype returns arraytype
	 *
	 * Constraint:
	 *     (expression=expression elementtype=elementtype)
	 */
	protected void sequence_arraytype(ISerializationContext context, arraytype semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ARRAYTYPE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ARRAYTYPE__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ARRAYTYPE__ELEMENTTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ARRAYTYPE__ELEMENTTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArraytypeAccess().getExpressionExpressionParserRuleCall_0_0_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getArraytypeAccess().getElementtypeElementtypeParserRuleCall_1_0(), semanticObject.getElementtype());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     assignmentaux returns assignmentaux
	 *
	 * Constraint:
	 *     (postexpressionlist+=postexpressionlist ASSIGN_OP=ASSIGN_OP expressionlist+=expressionlist)
	 */
	protected void sequence_assignmentaux(ISerializationContext context, assignmentaux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     commcase returns commcase
	 *
	 * Constraint:
	 *     (sendstmt=sendstmt | recvstmt=recvstmt)?
	 */
	protected void sequence_commcase(ISerializationContext context, commcase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     commclause returns commcase
	 *
	 * Constraint:
	 *     ((sendstmt=sendstmt | recvstmt=recvstmt)? statementlist=statementlist)
	 */
	protected void sequence_commcase_commclause(ISerializationContext context, commcase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     compositelit returns compositelit
	 *
	 * Constraint:
	 *     (literaltype=literaltype literalvalue=literalvalue)
	 */
	protected void sequence_compositelit(ISerializationContext context, compositelit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COMPOSITELIT__LITERALTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COMPOSITELIT__LITERALTYPE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COMPOSITELIT__LITERALVALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COMPOSITELIT__LITERALVALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompositelitAccess().getLiteraltypeLiteraltypeParserRuleCall_0_0(), semanticObject.getLiteraltype());
		feeder.accept(grammarAccess.getCompositelitAccess().getLiteralvalueLiteralvalueParserRuleCall_1_0(), semanticObject.getLiteralvalue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constdecl returns constdecl
	 *
	 * Constraint:
	 *     (constspec+=constspec | constspec+=constspec+)?
	 */
	protected void sequence_constdecl(ISerializationContext context, constdecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constspec returns constspec
	 *
	 * Constraint:
	 *     (identifierlist=identifierlist (type=type? expressionlist=expressionlist)?)
	 */
	protected void sequence_constspec(ISerializationContext context, constspec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     conversion returns conversion
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_conversion(ISerializationContext context, conversion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONVERSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONVERSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConversionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     declaration returns declaration
	 *     topleveldecl returns declaration
	 *
	 * Constraint:
	 *     (constdecl=constdecl | typedecl=typedecl | vardecl=vardecl)
	 */
	protected void sequence_declaration(ISerializationContext context, declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     elementlist returns key
	 *
	 * Constraint:
	 *     ((expression=expression | IDENTIFIER=IDENTIFIER | literalvalue=literalvalue) element=element keyedelement+=keyedelement*)
	 */
	protected void sequence_elementlist_key_keyedelement(ISerializationContext context, key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     elementlist returns keyedelement
	 *
	 * Constraint:
	 *     (element=element keyedelement+=keyedelement*)
	 */
	protected void sequence_elementlist_keyedelement(ISerializationContext context, keyedelement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     exprcaseclause returns exprcaseclause
	 *
	 * Constraint:
	 *     (exprswitchcase=exprswitchcase statementlist=statementlist)
	 */
	protected void sequence_exprcaseclause(ISerializationContext context, exprcaseclause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRCASECLAUSE__EXPRSWITCHCASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRCASECLAUSE__EXPRSWITCHCASE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRCASECLAUSE__STATEMENTLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRCASECLAUSE__STATEMENTLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExprcaseclauseAccess().getExprswitchcaseExprswitchcaseParserRuleCall_0_0(), semanticObject.getExprswitchcase());
		feeder.accept(grammarAccess.getExprcaseclauseAccess().getStatementlistStatementlistParserRuleCall_2_0(), semanticObject.getStatementlist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     recvstmt returns unaryexpr
	 *
	 * Constraint:
	 *     ((primaryexpr=primaryexpr | (UNARY_OP=UNARY_OP unaryexpr=unaryexpr)) expressionaux+=expressionaux expression+=expression* recvexpr=recvexpr)
	 */
	protected void sequence_expression_expressionlist_recvstmt_unaryexpr(ISerializationContext context, unaryexpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expressionlist returns unaryexpr
	 *
	 * Constraint:
	 *     ((primaryexpr=primaryexpr | (UNARY_OP=UNARY_OP unaryexpr=unaryexpr)) expressionaux+=expressionaux expression+=expression*)
	 */
	protected void sequence_expression_expressionlist_unaryexpr(ISerializationContext context, unaryexpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     forstmt returns unaryexpr
	 *
	 * Constraint:
	 *     ((primaryexpr=primaryexpr | (UNARY_OP=UNARY_OP unaryexpr=unaryexpr)) expressionaux+=expressionaux rangeclause=rangeclause? block=block)
	 */
	protected void sequence_expression_forstmt_unaryexpr(ISerializationContext context, unaryexpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expression returns unaryexpr
	 *     index returns unaryexpr
	 *     element returns unaryexpr
	 *     deferstmt returns unaryexpr
	 *     recvexpr returns unaryexpr
	 *     gotstmt returns unaryexpr
	 *
	 * Constraint:
	 *     ((primaryexpr=primaryexpr | (UNARY_OP=UNARY_OP unaryexpr=unaryexpr)) expressionaux+=expressionaux)
	 */
	protected void sequence_expression_unaryexpr(ISerializationContext context, unaryexpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expressionaux returns expressionaux
	 *
	 * Constraint:
	 *     (expression+=expression BINARY_OP=BINARY_OP expression+=expression)
	 */
	protected void sequence_expressionaux(ISerializationContext context, expressionaux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     exprswitchcase returns exprswitchcase
	 *
	 * Constraint:
	 *     expressionlist=expressionlist?
	 */
	protected void sequence_exprswitchcase(ISerializationContext context, exprswitchcase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     exprswitchstmt returns exprswitchstmt
	 *
	 * Constraint:
	 *     (simplestmt=simplestmt? expression=expression? exprcaseclause+=exprcaseclause*)
	 */
	protected void sequence_exprswitchstmt(ISerializationContext context, exprswitchstmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fielddecl returns fielddecl
	 *
	 * Constraint:
	 *     (((identifierlist=identifierlist type=type) | embeddedfield=embeddedfield) tag=tag?)
	 */
	protected void sequence_fielddecl(ISerializationContext context, fielddecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     forclause returns forclause
	 *
	 * Constraint:
	 *     (simplestmt+=simplestmt* expression=expression? simplestmt+=simplestmt?)
	 */
	protected void sequence_forclause(ISerializationContext context, forclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     forstmt returns forclause
	 *
	 * Constraint:
	 *     (simplestmt+=simplestmt* expression=expression? simplestmt+=simplestmt? block=block)
	 */
	protected void sequence_forclause_forstmt(ISerializationContext context, forclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     forstmt returns forstmt
	 *
	 * Constraint:
	 *     block=block
	 */
	protected void sequence_forstmt(ISerializationContext context, forstmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FORSTMT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FORSTMT__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForstmtAccess().getBlockBlockParserRuleCall_2_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     functiondecl returns functiondecl
	 *
	 * Constraint:
	 *     (functionname=functionname signature=signature functionbody=functionbody?)
	 */
	protected void sequence_functiondecl(ISerializationContext context, functiondecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     functionlit returns functionlit
	 *
	 * Constraint:
	 *     (signature=signature functionbody=functionbody)
	 */
	protected void sequence_functionlit(ISerializationContext context, functionlit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTIONLIT__SIGNATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTIONLIT__SIGNATURE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTIONLIT__FUNCTIONBODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTIONLIT__FUNCTIONBODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionlitAccess().getSignatureSignatureParserRuleCall_1_0(), semanticObject.getSignature());
		feeder.accept(grammarAccess.getFunctionlitAccess().getFunctionbodyFunctionbodyParserRuleCall_2_0(), semanticObject.getFunctionbody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ifstmt returns ifstmt
	 *
	 * Constraint:
	 *     (simplestmt=simplestmt? expression=expression block+=block (ifstmt=ifstmt | block+=block)?)
	 */
	protected void sequence_ifstmt(ISerializationContext context, ifstmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     interfacetype returns interfacetype
	 *
	 * Constraint:
	 *     methodspec+=methodspec*
	 */
	protected void sequence_interfacetype(ISerializationContext context, interfacetype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     key returns key
	 *
	 * Constraint:
	 *     (expression=expression | IDENTIFIER=IDENTIFIER | literalvalue=literalvalue)
	 */
	protected void sequence_key(ISerializationContext context, key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     keyedelement returns key
	 *
	 * Constraint:
	 *     ((expression=expression | IDENTIFIER=IDENTIFIER | literalvalue=literalvalue) element=element)
	 */
	protected void sequence_key_keyedelement(ISerializationContext context, key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     keyedelement returns keyedelement
	 *
	 * Constraint:
	 *     element=element
	 */
	protected void sequence_keyedelement(ISerializationContext context, keyedelement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.KEYEDELEMENT__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.KEYEDELEMENT__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyedelementAccess().getElementElementParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     labeledstmt returns labeledstmt
	 *
	 * Constraint:
	 *     (label=label statement=statement)
	 */
	protected void sequence_labeledstmt(ISerializationContext context, labeledstmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LABELEDSTMT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LABELEDSTMT__LABEL));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LABELEDSTMT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LABELEDSTMT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabeledstmtAccess().getLabelLabelParserRuleCall_0_0(), semanticObject.getLabel());
		feeder.accept(grammarAccess.getLabeledstmtAccess().getStatementStatementParserRuleCall_2_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     literal returns literal
	 *
	 * Constraint:
	 *     (basiclit=basiclit | compositelit=compositelit | functionlit=functionlit)
	 */
	protected void sequence_literal(ISerializationContext context, literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     literaltype returns literaltype
	 *
	 * Constraint:
	 *     (structtype=structtype | elementtype=elementtype | slicetype=slicetype | maptype=maptype | typename=typename)
	 */
	protected void sequence_literaltype(ISerializationContext context, literaltype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     literalvalue returns literalvalue
	 *     element returns literalvalue
	 *
	 * Constraint:
	 *     elementlist=elementlist?
	 */
	protected void sequence_literalvalue(ISerializationContext context, literalvalue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     maptype returns type
	 *
	 * Constraint:
	 *     ((type=type | typename=typename | typelit=typelit) elementtype=elementtype)
	 */
	protected void sequence_maptype_type(ISerializationContext context, type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     methoddecl returns methoddecl
	 *
	 * Constraint:
	 *     (receiver=receiver methodname=methodname signature=signature functionbody=functionbody?)
	 */
	protected void sequence_methoddecl(ISerializationContext context, methoddecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     methodexpr returns methodexpr
	 *
	 * Constraint:
	 *     methodname=methodname
	 */
	protected void sequence_methodexpr(ISerializationContext context, methodexpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.METHODEXPR__METHODNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.METHODEXPR__METHODNAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMethodexprAccess().getMethodnameMethodnameParserRuleCall_1_0(), semanticObject.getMethodname());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     methodspec returns methodspec
	 *
	 * Constraint:
	 *     ((methodname=methodname signature=signature) | interfacetypename=interfacetypename)
	 */
	protected void sequence_methodspec(ISerializationContext context, methodspec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     operand returns operand
	 *
	 * Constraint:
	 *     (expression=expression | literal=literal)
	 */
	protected void sequence_operand(ISerializationContext context, operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameterdecl returns parameterdecl
	 *
	 * Constraint:
	 *     (identifierlist=identifierlist? type=type)
	 */
	protected void sequence_parameterdecl(ISerializationContext context, parameterdecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameterlist returns parameterlist
	 *
	 * Constraint:
	 *     (parameterdecl+=parameterdecl parameterdecl+=parameterdecl*)
	 */
	protected void sequence_parameterlist(ISerializationContext context, parameterlist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     receiver returns parameters
	 *     result returns parameters
	 *     parameters returns parameters
	 *
	 * Constraint:
	 *     parameterlist=parameterlist?
	 */
	protected void sequence_parameters(ISerializationContext context, parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     postexpressionlist returns postexpressionlist
	 *
	 * Constraint:
	 *     expression+=expression*
	 */
	protected void sequence_postexpressionlist(ISerializationContext context, postexpressionlist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primaryexpr returns primaryexpr
	 *
	 * Constraint:
	 *     (
	 *         (operand=operand primaryexpraux=primaryexpraux) | 
	 *         (type=typeaux (conversion=conversion | methodexpr=methodexpr) primaryexpraux=primaryexpraux) | 
	 *         (typename=typename primaryexpraux=primaryexpraux)
	 *     )
	 */
	protected void sequence_primaryexpr(ISerializationContext context, primaryexpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primaryexpraux returns primaryexpraux
	 *
	 * Constraint:
	 *     (
	 *         ((selector=selector | typeassertion=typeassertion) primaryexpraux=primaryexpraux) | 
	 *         ((slice=slice | index=index) primaryexpraux=primaryexpraux) | 
	 *         (arguments=arguments primaryexpraux=primaryexpraux)
	 *     )?
	 */
	protected void sequence_primaryexpraux(ISerializationContext context, primaryexpraux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rangeclause returns rangeclause
	 *
	 * Constraint:
	 *     ((expressionlist=postexpressionlist | identifierlist=identifierlist)? expression=expression)
	 */
	protected void sequence_rangeclause(ISerializationContext context, rangeclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     recvstmt returns recvstmt
	 *
	 * Constraint:
	 *     (identifierlist=identifierlist recvexpr=recvexpr)
	 */
	protected void sequence_recvstmt(ISerializationContext context, recvstmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RECVSTMT__IDENTIFIERLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RECVSTMT__IDENTIFIERLIST));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RECVSTMT__RECVEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RECVSTMT__RECVEXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecvstmtAccess().getIdentifierlistIdentifierlistParserRuleCall_0_1_0_0(), semanticObject.getIdentifierlist());
		feeder.accept(grammarAccess.getRecvstmtAccess().getRecvexprRecvexprParserRuleCall_1_0(), semanticObject.getRecvexpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     returnstmt returns returnstmt
	 *
	 * Constraint:
	 *     expressionlist=expressionlist?
	 */
	protected void sequence_returnstmt(ISerializationContext context, returnstmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     selectstmt returns selectstmt
	 *
	 * Constraint:
	 *     commclause+=commclause*
	 */
	protected void sequence_selectstmt(ISerializationContext context, selectstmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     sendstmt returns sendstmt
	 *
	 * Constraint:
	 *     (expression+=expression expression+=expression)
	 */
	protected void sequence_sendstmt(ISerializationContext context, sendstmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     sendstmtaux returns sendstmtaux
	 *
	 * Constraint:
	 *     expression+=expression
	 */
	protected void sequence_sendstmtaux(ISerializationContext context, sendstmtaux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     shortvardecl returns shortvardecl
	 *
	 * Constraint:
	 *     (identifierlist=identifierlist expressionlist=expressionlist)
	 */
	protected void sequence_shortvardecl(ISerializationContext context, shortvardecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHORTVARDECL__IDENTIFIERLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHORTVARDECL__IDENTIFIERLIST));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SHORTVARDECL__EXPRESSIONLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SHORTVARDECL__EXPRESSIONLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShortvardeclAccess().getIdentifierlistIdentifierlistParserRuleCall_0_0(), semanticObject.getIdentifierlist());
		feeder.accept(grammarAccess.getShortvardeclAccess().getExpressionlistExpressionlistParserRuleCall_2_0(), semanticObject.getExpressionlist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     functiontype returns signature
	 *     signature returns signature
	 *
	 * Constraint:
	 *     (parameters=parameters result=result?)
	 */
	protected void sequence_signature(ISerializationContext context, signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     simplestmt returns simplestmt
	 *
	 * Constraint:
	 *     ((expression=expression (sendstmt=sendstmtaux | incdecstmt=incdecstmtaux | assignment=assignmentaux)?) | shortvardecl=shortvardecl)
	 */
	protected void sequence_simplestmt(ISerializationContext context, simplestmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeswitchstmt returns simplestmt
	 *
	 * Constraint:
	 *     (
	 *         ((expression=expression (sendstmt=sendstmtaux | incdecstmt=incdecstmtaux | assignment=assignmentaux)?) | shortvardecl=shortvardecl) 
	 *         typeswitchguard=typeswitchguard 
	 *         typecaseclause+=typecaseclause*
	 *     )
	 */
	protected void sequence_simplestmt_typeswitchstmt(ISerializationContext context, simplestmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     slice returns slice
	 *
	 * Constraint:
	 *     (expression+=expression? ((expression+=expression expression+=expression) | expression+=expression)?)
	 */
	protected void sequence_slice(ISerializationContext context, slice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     sourcefile returns sourcefile
	 *
	 * Constraint:
	 *     (packageclause+=packageclause importdecl+=importdecl* topleveldecl+=topleveldecl*)
	 */
	protected void sequence_sourcefile(ISerializationContext context, sourcefile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement returns statement
	 *
	 * Constraint:
	 *     (
	 *         simplestmt=simplestmt | 
	 *         declaration=declaration | 
	 *         labeledstmt=labeledstmt | 
	 *         gotstmt=gotstmt | 
	 *         returnstmt=returnstmt | 
	 *         breakstmt=breakstmt | 
	 *         continuestmt=continuestmt | 
	 *         gotostmt=gotostmt | 
	 *         fallthroughstmt=fallthroughstmt | 
	 *         block=block | 
	 *         ifstmt=ifstmt | 
	 *         switchstmt=switchstmt | 
	 *         selectstmt=selectstmt | 
	 *         forstmt=forstmt | 
	 *         deferstmt=deferstmt
	 *     )
	 */
	protected void sequence_statement(ISerializationContext context, statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     block returns statementlist
	 *     statementlist returns statementlist
	 *     functionbody returns statementlist
	 *
	 * Constraint:
	 *     statement+=statement*
	 */
	protected void sequence_statementlist(ISerializationContext context, statementlist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     structtype returns structtype
	 *
	 * Constraint:
	 *     fielddecl+=fielddecl*
	 */
	protected void sequence_structtype(ISerializationContext context, structtype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     switchstmt returns switchstmt
	 *
	 * Constraint:
	 *     (exprswitchstmt=exprswitchstmt | typeswitchstmt=typeswitchstmt)
	 */
	protected void sequence_switchstmt(ISerializationContext context, switchstmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     topleveldecl returns topleveldecl
	 *
	 * Constraint:
	 *     (functiondecl=functiondecl | methoddecl=methoddecl)
	 */
	protected void sequence_topleveldecl(ISerializationContext context, topleveldecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns type
	 *     typeassertion returns type
	 *     slicetype returns type
	 *     pointertype returns type
	 *     basetype returns type
	 *     channeltype returns type
	 *     keytype returns type
	 *     elementtype returns type
	 *     result returns type
	 *
	 * Constraint:
	 *     (type=type | typename=typename | typelit=typelit)
	 */
	protected void sequence_type(ISerializationContext context, type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeaux returns typeaux
	 *
	 * Constraint:
	 *     (type=type | typelit=typelit)
	 */
	protected void sequence_typeaux(ISerializationContext context, typeaux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typecaseclause returns typecaseclause
	 *
	 * Constraint:
	 *     (typeswitchcase=typeswitchcase statementlist=statementlist)
	 */
	protected void sequence_typecaseclause(ISerializationContext context, typecaseclause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPECASECLAUSE__TYPESWITCHCASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPECASECLAUSE__TYPESWITCHCASE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPECASECLAUSE__STATEMENTLIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPECASECLAUSE__STATEMENTLIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypecaseclauseAccess().getTypeswitchcaseTypeswitchcaseParserRuleCall_0_0(), semanticObject.getTypeswitchcase());
		feeder.accept(grammarAccess.getTypecaseclauseAccess().getStatementlistStatementlistParserRuleCall_2_0(), semanticObject.getStatementlist());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     typedecl returns typedecl
	 *
	 * Constraint:
	 *     (typespec+=typespec | typespec+=typespec+)?
	 */
	protected void sequence_typedecl(ISerializationContext context, typedecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typespecaux returns typedef
	 *     typedef returns typedef
	 *
	 * Constraint:
	 *     type=type
	 */
	protected void sequence_typedef(ISerializationContext context, typedef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPESPECAUX__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPESPECAUX__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypedefAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     typelist returns typelist
	 *
	 * Constraint:
	 *     type+=type*
	 */
	protected void sequence_typelist(ISerializationContext context, typelist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typelit returns typelit
	 *
	 * Constraint:
	 *     (
	 *         arraytype=arraytype | 
	 *         structtype=structtype | 
	 *         pointertype=pointertype | 
	 *         functiontype=functiontype | 
	 *         interfacetype=interfacetype | 
	 *         slicetype=slicetype | 
	 *         maptype=maptype | 
	 *         channeltype=channeltype
	 *     )
	 */
	protected void sequence_typelit(ISerializationContext context, typelit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typespec returns typespec
	 *
	 * Constraint:
	 *     (IDENTIFIER=IDENTIFIER typespecaux=typespecaux)
	 */
	protected void sequence_typespec(ISerializationContext context, typespec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPESPEC__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPESPEC__IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPESPEC__TYPESPECAUX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPESPEC__TYPESPECAUX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypespecAccess().getIDENTIFIERIDENTIFIERTerminalRuleCall_0_0(), semanticObject.getIDENTIFIER());
		feeder.accept(grammarAccess.getTypespecAccess().getTypespecauxTypespecauxParserRuleCall_1_0(), semanticObject.getTypespecaux());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     typeswitchcase returns typeswitchcase
	 *
	 * Constraint:
	 *     typelist=typelist?
	 */
	protected void sequence_typeswitchcase(ISerializationContext context, typeswitchcase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeswitchguard returns typeswitchguard
	 *
	 * Constraint:
	 *     (IDENTIFIER=IDENTIFIER? primaryexpr=primaryexpr)
	 */
	protected void sequence_typeswitchguard(ISerializationContext context, typeswitchguard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeswitchstmt returns typeswitchstmt
	 *
	 * Constraint:
	 *     (typeswitchguard=typeswitchguard typecaseclause+=typecaseclause*)
	 */
	protected void sequence_typeswitchstmt(ISerializationContext context, typeswitchstmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unaryexpr returns unaryexpr
	 *
	 * Constraint:
	 *     (primaryexpr=primaryexpr | (UNARY_OP=UNARY_OP unaryexpr=unaryexpr))
	 */
	protected void sequence_unaryexpr(ISerializationContext context, unaryexpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     vardecl returns vardecl
	 *
	 * Constraint:
	 *     (varspec+=varspec | varspec+=varspec+)?
	 */
	protected void sequence_vardecl(ISerializationContext context, vardecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     varspec returns varspec
	 *
	 * Constraint:
	 *     (identifierlist=identifierlist ((type=type expressionlist=expressionlist) | expressionlist=expressionlist))
	 */
	protected void sequence_varspec(ISerializationContext context, varspec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
